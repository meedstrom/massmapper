#+TITLE: Massmapper
#+AUTHOR: Martin Edstr√∂m
#+EMAIL: meedstrom91@gmail.com
#+LANGUAGE: en
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright
# notice and this notice are preserved.  This file is offered as-is,
# without any warranty.

# [[https://img.shields.io/badge/license-GPL3+-blue.png]]

The long-absent Emacs facility to systematically remap key bindings.

Ever wished you could just "remap Control to Super", in a way that doesn't make things weird?  Then you're in luck, that's the sort of thing we do here.

* Install

Requires Emacs 28+.

Not yet on (M)ELPA.  With [[https://github.com/raxod502/straight.el][straight.el]] and =straight-enable-use-package-integration=, you can install the package like so:

#+begin_src elisp
(use-package massmapper
  :straight (massmapper :type git :host github :repo "meedstrom/massmapper"))
#+end_src

Alternatively with Doom Emacs, this goes in =packages.el=:

#+begin_src elisp
(package! massmapper :recipe (:host github :repo "meedstrom/massmapper"))
#+end_src

* Setup

To configure, add any of these hooks:

#+begin_src elisp
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-super-like-ctl)
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-super-like-ctlmeta)
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-super-like-meta)
#+end_src

and any of:

#+begin_src elisp
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-alt-like-ctl)
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-alt-like-ctlmeta)
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-alt-like-meta)
#+end_src

and any of:

#+begin_src elisp
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-hyper-like-ctl)
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-hyper-like-ctlmeta)
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-hyper-like-meta)
#+end_src

and any of (experimental):

#+begin_src elisp
(add-hook 'massmapper-keymap-found-hook #'massmapper-define-metasuper-like-ctlmeta)
(add-hook 'massmapper-keymap-found-hook #'massmapper-protect-ret-and-tab)
#+end_src

and finally, for those of you coming here from [[https://github.com/meedstrom/deianira][Deianira]], this is the great homogenizer and Raison D'Etre:

#+begin_src elisp
(add-hook 'massmapper-keymap-found-hook #'massmapper-homogenize-keymaps -50)
#+end_src

(More options to come)

Finally, turn it on by typing =M-x massmapper-mode RET=.

To see what has been remapped, try =M-x massmapper-list-remaps RET=.

* Appendix
*** Tip: Binding under the "old" prefix

Let's say you want to stop using the Control key altogether in favour of Super.

Even then, it can look clean to *bind only Control keys in your initfiles*, knowing that =massmapper-define-super-like-ctl= will copy everything to Super for you.

I.e. to keep binding "C-" keys instead of "s-" keys.

One advantage of doing so is that Control and Super then perfectly mirror each other, useful in the event Super has a service outage for any reason, like you install GNOME or you enter the TTY, or you plug in on a keyboard that lacks a Right Super key but has a Right Control, or vice versa.

There can be cases when you want a Super key to behave different from the Control key it was supposed to mirror.  In that case, simply bind it directly, and Massmapper will respect it.

A typical example is =s-m=.  Since you cannot re-bind =C-m= without destroying your =RET= key, you would probably never re-bind =C-m=.  But you can bind =s-m= to anything you please!

Just mind that global-map is the lowest-priority keymap.  So if you want a new =s-m= that applies everywhere, you probably want to bind it in General's =general-override-mode-map= or using bind-key's =bind-key*=.

*** Under the hood

If you're curious about what the package does to your Emacs, it may be nice to set =(setq massmapper-debug-level 1)= for a while.

When you develop a package like this, you run into many gotchas.  I had to learn not to utilize key translations such as =(define-key key-translation-map (kbd "C-c") (kbd "s-c"))= even though they seem clean.

So what does Massmapper do?  It just scans each and every keymap variable, such as =global-map=, =org-mode-map= and =projectile-mode-map=, and makes new key-bindings inside each, based on other key-bindings found within.  Brute-force, but works as intended 100% of the time.

# *** Tip: Declutter which-key after homogenize

# #+begin_src elisp
# ;; Hide any key sequence involving more than one chord.  We have no reason to
# ;; see them after using `massmapper-homogenize'.
# (with-eval-after-load 'which-key
#   (cl-pushnew '((" .-." . nil) . t) which-key-replacement-alist))
# #+end_src

*** Gotcha: bind now, not later

In your initfiles, it's safest to place your =(massmapper-mode)= invocation somewhere /after/ all key-bindings are done.  If you don't have an excellent overview of your initfiles, after-init-hook is reasonable:

: (add-hook 'after-init-hook #'massmapper-mode)

This may sound like you should worry about key-bindings made inside =with-eval-after-load= and the like, but that's not a problem -- Massmapper will work correctly.

Unless you do something like this:

#+begin_src elisp
(with-eval-after-load 'eshell
  (with-eval-after-load 'helm
    (define-key global-map (kbd "M-r") #'helm-eshell-prompts-all)))
#+end_src

i.e. you add a binding to global-map only after eshell and helm have loaded.

This is not the way.  Bind your keys in each map /as they come into existence/, and don't touch them from then on.  For global-map, that means bind everything at init time!

The above is better done as simply

#+begin_src elisp
(define-key global-map (kbd "M-r") #'helm-eshell-prompts-all)
#+end_src

and letting built-in autoloads load Helm and Eshell.  Then things that inspect keymaps, such as this package, always have the correct idea.

# ------

# It's possible I should make some sort of "=massmapper-refresh=" command for strange use cases -- TBD.  But consider doing different what you're doing.

*** Gotcha: C-g is a hardcoded "unfreeze Emacs"

Emacs hardcodes =C-g= as the "unfreeze Emacs" key.

Unfortunately when Emacs freezes, nothing else than =C-g= will get it out of that state.  This package will dutifully copy the =keyboard-quit= command to =s-g= or wherever, but when Emacs is frozen, the keymaps aren't being looked up at all!

I'm sure that many people through the ages have tried in good faith to bind =keyboard-quit= to =<escape>= or some such, only to give up eventually when they saw that the result wasn't consistent.

I surmise we can't remove the =C-g= behavior from =C-g= itself because of TTYs, but it should be possible to add /more/ keyboard interrupts than just =C-g=.  Emacs would probably need a compile-time option, which could maybe become a startup parameter or Lisp setting.

There is nothing Massmapper can do from within Emacs Lisp.

*** Gotcha: C-g is sometimes a hardcoded "cancel-button"
Aside from the above, some Emacs Lisp functions hardcode =C-g= as a "cancel" action, but this can usually be circumvented with a key-translation---which for your information, Massmapper won't do by default.  This tends to do the trick:

#+begin_src elisp
(define-key input-decode-map (kbd "s-g") (kbd "C-g"))
#+end_src

In very rare cases, mainly =map-y-or-n-p= that I've seen, a function [[https://lists.gnu.org/archive/html/bug-gnu-emacs/2022-10/msg02195.html][actually uses read-event]] so that key-translations do nothing!  That's properly considered a bug and should be reported upstream.

*** Aside for developers

*If you're an Emacs Lisp programmer* wondering what's the appropriate thing to do instead of referring to =C-g=, it's to create a minor or major mode map and just remap =keyboard-quit= in there, making no assumption about what the user has on C-g or where =keyboard-quit= may be. I.e. do this:

#+begin_src elisp
(defvar-keymap my-map)
(define-key my-map [remap keyboard-quit] #'my-keyboard-quit-wrapper)
;; if my-map may be activated in a minibuffer
(define-key my-map [remap abort-recursive-edit] #'my-abort-recursive-edit-wrapper)
#+end_src

not this:

#+begin_src elisp
(defvar-keymap my-map)
(define-key my-map (kbd "C-g") #'my-special-cancel)
#+end_src

If you must refer directly to a key in some custom interaction, definitely don't use =read-event=, =read-char= or =read-char-exclusive=, because they don't respect key translations!  These demon functions should trigger warnings in package-lint and the like.
# (but really, =use-local-map= and =set-transient-map= often work well)

The correct function is =read-key=, or higher-level functions such as =read-char-choice=, =read-multiple-choice=, =read-answer=, =read-char-from-minibuffer=, =y-or-n-p= etc.  See the Info manual chapter "(elisp)Reading Input".

Note that your imaginary =my-keyboard-quit-wrapper= should probably call =keyboard-quit= itself at the end.

As an alternative, you can try to design your program in such a way that when a keyboard-quit comes, the right thing would happen automatically, but that's more art than science.
